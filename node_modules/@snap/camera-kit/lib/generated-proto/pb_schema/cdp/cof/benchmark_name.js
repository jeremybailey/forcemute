/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
export const protobufPackage = "snapchat.cdp.cof";
/** Benchmark name. Ideally, a name should be short and unambiguous with unit included. */
export var BenchmarkName;
(function (BenchmarkName) {
    BenchmarkName[BenchmarkName["UNKNOWN_BENCHMARK"] = 0] = "UNKNOWN_BENCHMARK";
    BenchmarkName[BenchmarkName["CPU_GFLOPS"] = 1] = "CPU_GFLOPS";
    /** GPU_GFLOPS - GFLOPS when performing single unit operations */
    BenchmarkName[BenchmarkName["GPU_GFLOPS"] = 2] = "GPU_GFLOPS";
    /** GPU_GFLOPS_VECTOR - GFLOPS when performing vector operations */
    BenchmarkName[BenchmarkName["GPU_GFLOPS_VECTOR"] = 3] = "GPU_GFLOPS_VECTOR";
    /** GPU_SYSTEM_CAPABILITIES - JSON object containing GPU feature support derived from OpenGL/CL API */
    BenchmarkName[BenchmarkName["GPU_SYSTEM_CAPABILITIES"] = 4] = "GPU_SYSTEM_CAPABILITIES";
    /** GPU_VERTEX_THROUGHPUT - Vertices per second */
    BenchmarkName[BenchmarkName["GPU_VERTEX_THROUGHPUT"] = 5] = "GPU_VERTEX_THROUGHPUT";
    /** GPU_SIMPLE_GEOMETRY_THROUGHPUT - Vertices per second */
    BenchmarkName[BenchmarkName["GPU_SIMPLE_GEOMETRY_THROUGHPUT"] = 6] = "GPU_SIMPLE_GEOMETRY_THROUGHPUT";
    /** GPU_GAUSSIAN_BLUR - Sampling radius */
    BenchmarkName[BenchmarkName["GPU_GAUSSIAN_BLUR"] = 7] = "GPU_GAUSSIAN_BLUR";
    /** CPU_MEMORY_THROUGHPUT - MB per second */
    BenchmarkName[BenchmarkName["CPU_MEMORY_THROUGHPUT"] = 8] = "CPU_MEMORY_THROUGHPUT";
    /** GPU_FILL_RATE - Pixels per second */
    BenchmarkName[BenchmarkName["GPU_FILL_RATE"] = 9] = "GPU_FILL_RATE";
    /** MEM_TOTAL_MEMORY - Total memory of the system */
    BenchmarkName[BenchmarkName["MEM_TOTAL_MEMORY"] = 10] = "MEM_TOTAL_MEMORY";
    /** CPU_NUM_PROCESSORS - Gathers the number of CPUs the device has */
    BenchmarkName[BenchmarkName["CPU_NUM_PROCESSORS"] = 11] = "CPU_NUM_PROCESSORS";
    /** DEVICE_INFORMATION_CHIPSET - Returns the Chipset of the device via Build.BOARD */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_CHIPSET"] = 12] = "DEVICE_INFORMATION_CHIPSET";
    /** DEVICE_INFORMATION_BUILD_HARDWARE - Returns the Build.HARDWARE data for a device. This can be the chipset for some devices */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_BUILD_HARDWARE"] = 13] = "DEVICE_INFORMATION_BUILD_HARDWARE";
    /** DEVICE_INFORMATION_BUILD_BRAND - Returns the Build.BRAND for the device. This is normally the marketed brand for a device. */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_BUILD_BRAND"] = 14] = "DEVICE_INFORMATION_BUILD_BRAND";
    /** DEVICE_INFORMATION_BUILD_MANUFACTURER - Returns the Build.MANUFACTURER for the device. This is what company physically assembled the device */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_BUILD_MANUFACTURER"] = 15] = "DEVICE_INFORMATION_BUILD_MANUFACTURER";
    /** DEVICE_INFORMATION_BUILD_MODEL - Returns the Build.MODEL for the device. This is normally how we identify a device as 'SM-G930V' */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_BUILD_MODEL"] = 16] = "DEVICE_INFORMATION_BUILD_MODEL";
    /** DEVICE_INFORMATION_SCREEN_PROPERTIES - Returns the screen configuration from the device such as widthPixels and density. */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_SCREEN_PROPERTIES"] = 17] = "DEVICE_INFORMATION_SCREEN_PROPERTIES";
    /** DEVICE_INFORMATION_CODEC_CAPABILITES - Gathers the codec capabilities for the device. Such as HEVC and 264 profiles supported for encode/decode */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_CODEC_CAPABILITES"] = 18] = "DEVICE_INFORMATION_CODEC_CAPABILITES";
    /** CPU_PRIME_KOTLIN - Calculates primes in Kotlin using sieve */
    BenchmarkName[BenchmarkName["CPU_PRIME_KOTLIN"] = 19] = "CPU_PRIME_KOTLIN";
    /** CPU_PRIME_NATIVE - Calculates primes in C++ using sieve */
    BenchmarkName[BenchmarkName["CPU_PRIME_NATIVE"] = 20] = "CPU_PRIME_NATIVE";
    /** CPU_SQRT_KOTLIN - Calculates sqrt using the babylonian method in kotlin */
    BenchmarkName[BenchmarkName["CPU_SQRT_KOTLIN"] = 21] = "CPU_SQRT_KOTLIN";
    /** CPU_SQRT_NATIVE - Calculates sqrt using the babylonian method in C++ */
    BenchmarkName[BenchmarkName["CPU_SQRT_NATIVE"] = 22] = "CPU_SQRT_NATIVE";
    /** CPU_INT_MATH_KOTLIN - Performs a serious of int ALU computations in kotlin */
    BenchmarkName[BenchmarkName["CPU_INT_MATH_KOTLIN"] = 23] = "CPU_INT_MATH_KOTLIN";
    /** CPU_INT_MATH_NATIVE - Performs a serious of int ALU computations in C++ */
    BenchmarkName[BenchmarkName["CPU_INT_MATH_NATIVE"] = 24] = "CPU_INT_MATH_NATIVE";
    /** DEVICE_INFORMATION_GL_VERSION - OpenGL version running on the device, calculated as (100 * major) + minor, ex. "OpenGL ES 3.2" -> 302 */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GL_VERSION"] = 25] = "DEVICE_INFORMATION_GL_VERSION";
    /** DEVICE_INFORMATION_GLSL_VERSION - GLSL version running on the device, calculated as (100 * major) + minor, ex. "OpenGL ES GLSL ES 3.20" -> 320 */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GLSL_VERSION"] = 26] = "DEVICE_INFORMATION_GLSL_VERSION";
    /** DEVICE_INFORMATION_OPENCL_EXISTS - True if we can run OpenCL on this device, otherwise false */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_OPENCL_EXISTS"] = 27] = "DEVICE_INFORMATION_OPENCL_EXISTS";
    /** DEVICE_INFORMATION_IS_HOST_UNIFIED_MEMORY - True if the device is using a unified memory architecture */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_IS_HOST_UNIFIED_MEMORY"] = 28] = "DEVICE_INFORMATION_IS_HOST_UNIFIED_MEMORY";
    /** DEVICE_INFORMATION_OPENCL_VERSION - OpenCL version running on the device, calculated as (100 * major) + minor, ex. "OpenCL 1.2" -> 102 */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_OPENCL_VERSION"] = 29] = "DEVICE_INFORMATION_OPENCL_VERSION";
    /** DEVICE_INFORMATION_TIMING_RESOLUTION_NS - Timing resolution in nanoseconds for profiling reported by OpenCL */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_TIMING_RESOLUTION_NS"] = 30] = "DEVICE_INFORMATION_TIMING_RESOLUTION_NS";
    /** DEVICE_INFORMATION_ADDRESS_SIZE - Number of bits used to address memory (32-bit, 64-bit) */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_ADDRESS_SIZE"] = 31] = "DEVICE_INFORMATION_ADDRESS_SIZE";
    /** DEVICE_INFORMATION_GPU_MAX_CLOCK_FREQUENCY_MHZ - Maximum clock frequency of the device in MHz */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GPU_MAX_CLOCK_FREQUENCY_MHZ"] = 32] = "DEVICE_INFORMATION_GPU_MAX_CLOCK_FREQUENCY_MHZ";
    /** DEVICE_INFORMATION_COMPUTE_UNITS - Number of available compute units on the device */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_COMPUTE_UNITS"] = 33] = "DEVICE_INFORMATION_COMPUTE_UNITS";
    /** DEVICE_INFORMATION_MAX_WORKGROUP_SIZE - Maximum number of tasks that can be processed at one time by a workgroup */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_MAX_WORKGROUP_SIZE"] = 34] = "DEVICE_INFORMATION_MAX_WORKGROUP_SIZE";
    /** DEVICE_INFORMATION_LOCAL_MEMORY_IS_LOCAL - True if the device has dedicated local memory storage */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_LOCAL_MEMORY_IS_LOCAL"] = 35] = "DEVICE_INFORMATION_LOCAL_MEMORY_IS_LOCAL";
    /** DEVICE_INFORMATION_LOCAL_MEMORY_SIZE - Amount of local memory storage in bytes */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_LOCAL_MEMORY_SIZE"] = 36] = "DEVICE_INFORMATION_LOCAL_MEMORY_SIZE";
    /** DEVICE_INFORMATION_GLOBAL_MEMORY_CACHE_SIZE - Amount of global memory cache in bytes */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GLOBAL_MEMORY_CACHE_SIZE"] = 37] = "DEVICE_INFORMATION_GLOBAL_MEMORY_CACHE_SIZE";
    /** DEVICE_INFORMATION_GLOBAL_MEMORY_CACHELINE_SIZE - Line size for global memory cache in bytes */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GLOBAL_MEMORY_CACHELINE_SIZE"] = 38] = "DEVICE_INFORMATION_GLOBAL_MEMORY_CACHELINE_SIZE";
    /** DEVICE_INFORMATION_GL_HAS_FENCE_SYNC_OBJECT - True if device reports support for GL fence sync objects */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GL_HAS_FENCE_SYNC_OBJECT"] = 39] = "DEVICE_INFORMATION_GL_HAS_FENCE_SYNC_OBJECT";
    /** DEVICE_INFORMATION_HEXAGON_NN_LIBRARY_VERSION - Supported hexagon nn library version. 0 if hexagon nn is not suppoted */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_HEXAGON_NN_LIBRARY_VERSION"] = 40] = "DEVICE_INFORMATION_HEXAGON_NN_LIBRARY_VERSION";
    /** GPU_GFLOPS_V2 - New GPU_GFLOPS benchmark expected to have better convergence properties than GPU_GFLOPS */
    BenchmarkName[BenchmarkName["GPU_GFLOPS_V2"] = 41] = "GPU_GFLOPS_V2";
    /** GPU_GFLOPS_VECTOR_V2 - New GPU_GFLOPS_VECTOR benchmark expected to have better convergence properties than GPU_GFLOPS_VECTOR */
    BenchmarkName[BenchmarkName["GPU_GFLOPS_VECTOR_V2"] = 42] = "GPU_GFLOPS_VECTOR_V2";
    /** DEVICE_INFORMATION_GPU_MODEL - GPU Model, e.g. Adreno (TM) 308, Mali-300 */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_GPU_MODEL"] = 43] = "DEVICE_INFORMATION_GPU_MODEL";
    /** DEVICE_INFORMATION_CODEC_CAPABILITES_V2 - Gathers more comprehensive info about media codec capabilities of the device */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_CODEC_CAPABILITES_V2"] = 44] = "DEVICE_INFORMATION_CODEC_CAPABILITES_V2";
    /** DEVICE_INFORMATION_MEDIA_PERFORMANCE_CLASS - Media performance class, e.g. 12, 13 and details:https://developer.android.com/topic/performance/performance-class */
    BenchmarkName[BenchmarkName["DEVICE_INFORMATION_MEDIA_PERFORMANCE_CLASS"] = 45] = "DEVICE_INFORMATION_MEDIA_PERFORMANCE_CLASS";
    BenchmarkName[BenchmarkName["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BenchmarkName || (BenchmarkName = {}));
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
//# sourceMappingURL=benchmark_name.js.map