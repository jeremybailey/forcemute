import _m0 from "protobufjs/minimal";
import { Namespace } from "./namespace";
import { BenchmarkResult } from "./benchmark";
import { Ruid } from "../../common/ruid";
export declare const protobufPackage = "snapchat.cdp.cof";
/** Indicates what was the state of the app when the config sync was triggered */
export declare enum ConfigTargetingTriggerEventType {
    /** UNKNOWN_EVENT_TYPE - Unknown */
    UNKNOWN_EVENT_TYPE = 0,
    /** COLD_START - Deprecated because of simplification to FG/BG */
    COLD_START = 1,
    /** WARM_START - Deprecated because of simplification to FG/BG */
    WARM_START = 2,
    /** FOREGROUND_TRIGGER - Triggered when application is in the foreground */
    FOREGROUND_TRIGGER = 3,
    /** BACKGROUND_TRIGGER - Triggered when application is backgrounded */
    BACKGROUND_TRIGGER = 4,
    UNRECOGNIZED = -1
}
/**
 * Indicates what was the state of the app when the config sync happens
 * The enum is also used as a dynamic client property to populate feature signals
 */
export declare enum ConfigTargetingAppState {
    /** UNKNOWN_APP_STATE - Unknown */
    UNKNOWN_APP_STATE = 0,
    /** FOREGROUND - Foreground */
    FOREGROUND = 1,
    /** BACKGROUND - Background */
    BACKGROUND = 2,
    UNRECOGNIZED = -1
}
/**
 * We expect this enum to be updated whenever there is a new sync instrumentation: This will help us isolate new changes on
 * server side to avoid post mortems like https://snapchat.quip.com/xGnVAcsBrOeC
 */
export declare enum ConfigTargetingInstrumentation {
    /** DEFAULT_INSTRUMENTATION - Default */
    DEFAULT_INSTRUMENTATION = 0,
    /** USER_AUTHENTICATION - User logged in */
    USER_AUTHENTICATION = 1,
    UNRECOGNIZED = -1
}
/**
 * The request contains targeting signals that are not already part of the User Agent.
 * Note the user agent is passed via the standard HTTP header hence not part of the request proto.
 */
export interface ConfigTargetingRequest {
    /**
     * The previously received etag, an empty list of ConfigResult will be returned if this matches
     * the newly computed etag.
     */
    configResultsEtag: string;
    /**
     * Caller can provide at most one field from "namespaces" and "config_names"
     * If not empty only return the matched configs in these namespaces.
     * If empty return all matched configs.
     */
    namespaces: Namespace[];
    /**
     * Deprecated
     *
     * @deprecated
     */
    ghostId: string;
    /** ISO ALPHA-2 Country Code (lowercase) */
    countryCode: string;
    /** The width in pixel of client screen. */
    screenWidth: number;
    /** The height in pixel of client screen. */
    screenHeight: number;
    /** Current device connectivity */
    connectivity: Connectivity | undefined;
    /** The maximum playable video width (assumes portrait orientation) */
    maxVideoWidthPx: number;
    /** The maximum playable video height (assumes portrait orientation) */
    maxVideoHeightPx: number;
    /** Client reports results from benchmark executions. */
    benchmarkResults: BenchmarkResult[];
    /** If set the server will only return the config results that are new or have changed. */
    deltaSync: boolean;
    /**
     * User Agent used for server to server request, which takes precedence over the User-Agent header
     *
     * @deprecated
     */
    userAgent: string;
    /** Type of event that triggers client to sync server */
    triggerEventType: ConfigTargetingTriggerEventType;
    /** App state when config targeting sync happens */
    appState: ConfigTargetingAppState;
    /**
     * Locale of the client.
     *
     * @deprecated
     */
    locale: string;
    /** Need to set this field for AB service if user id is not available (before user login). */
    deviceId: string;
    /**
     * Deprecated! This field won't be used! For server-initiated requests, set userId in "x-snap-cof-principal" header
     *
     * @deprecated
     */
    userId: string;
    /**
     * client ip is used for server to client ip to cof server.
     *
     * @deprecated
     */
    clientIp: string;
    /** If true, this is a request before user login. */
    isUnAuthorized: boolean;
    /** App locale in client. This may be different from device locale, which will be passed from header "Accept-Language". */
    appLocale: string;
    /** Location of config targeting sync invocation. */
    instrumentation: ConfigTargetingInstrumentation;
    /**
     * Timestamp in seconds from unix epoc that is the last time that this client was able to sync with the service.
     * This is used for us to optimize delta syncing infrastructure.
     */
    lastSuccessfulSync: number;
    /** This sync triggered by user logout. */
    isLogout: boolean;
    /** The source of app install (Android Only) */
    packageInstaller: string;
    /** Session ID that blizzard has when a COF sync is triggered */
    syncTriggerBlizzardSessionId: string;
    /** Session ID that blizzard has when a COF sync is executed */
    syncExecutionBlizzardSessionId: string;
    /** The delay between when the app is started and cof sync is triggered */
    cofSyncTriggerDelayFromStartupMs: number;
    /** The delay between when the app is started and cof sync starts to execute */
    cofSyncExecutionDelayFromStartupMs: number;
    /** Timestamp in seconds of the time the sync was triggered */
    syncTriggerTime: number;
    /** Allows client to signal what kind of media encoders/decoders are available */
    decoderEncoderAvailability: DecoderEncoderAvailablity | undefined;
    /** SnapKit app id from SnapKit Dev Portal */
    snapkitAppId: string;
    /** Lens core version which will be passed by all clients */
    lenscoreVersion: number;
    /**
     * Can represent any ID such as user_id, device_id, web_client_id; When present, its value override the corresponding
     * fields in the request
     */
    ruid: Ruid | undefined;
    /**
     * Caller can provide at most one field from "namespaces" and "config_names"
     * If not empty only return the matched configs
     */
    configNames: string[];
    /**
     * If true response will include TEST_USER allowlisted treatments
     * This is necessary for pre-login syncs where we do not yet know the user that will be logged in
     * Only works on internal builds AND if user is not logged-in.
     * See https://jira.sc-corp.net/browse/DAPSUPPORT-3363 for more context.
     */
    includeTestUserTreatments: boolean;
    /** whether to log exposure logging, default is to log exposure */
    disableExposureLogging: boolean;
    /**
     * Override value for the LENS_CLUSTER_ORIG_4 targeting property so that browser clients can
     * implement their own device benchmarking for lenses.
     */
    lensClusterOrig4: number;
    /**
     * ClientID is similar to device ID but it rotates after 30 days.
     * Used for allocation logs for device id AB Studies triggered in the server side
     */
    clientId: string;
}
/** Connectivity */
export interface Connectivity {
    /** Current network connection type */
    networkType: Connectivity_NetworkType;
    /**
     * A network is classified as metered when the user is sensitive to heavy data usage
     * on that connection due to monetary costs, data limitations or battery/performance issues.
     */
    isMetered: boolean | undefined;
    /** Whether or not client is roaming */
    isRoaming: boolean | undefined;
    /** String representing what carrier is providing the device with internet. */
    carrier: string;
}
/** NetworkType */
export declare enum Connectivity_NetworkType {
    /** UNKNOWN_NETWORK_TYPE - Unknown */
    UNKNOWN_NETWORK_TYPE = 0,
    /** CELLULAR - Cellular */
    CELLULAR = 1,
    /** WIFI - Wifi */
    WIFI = 2,
    UNRECOGNIZED = -1
}
export interface DecoderEncoderAvailablity {
    /** Signals that snapchat's custom VP9 software decoder library is available on the client */
    isSnapVp9DecoderAvailable: boolean;
    /** Signals that snapchat's custom AV1 software decoder library is available on the client */
    isSnapAv1DecoderAvailable: boolean;
}
export declare const ConfigTargetingRequest: {
    encode(message: ConfigTargetingRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ConfigTargetingRequest;
    fromPartial<I extends {
        configResultsEtag?: string | undefined;
        namespaces?: Namespace[] | undefined;
        ghostId?: string | undefined;
        countryCode?: string | undefined;
        screenWidth?: number | undefined;
        screenHeight?: number | undefined;
        connectivity?: {
            networkType?: Connectivity_NetworkType | undefined;
            isMetered?: boolean | undefined;
            isRoaming?: boolean | undefined;
            carrier?: string | undefined;
        } | undefined;
        maxVideoWidthPx?: number | undefined;
        maxVideoHeightPx?: number | undefined;
        benchmarkResults?: {
            name?: import("./benchmark_name").BenchmarkName | undefined;
            value?: {
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } | undefined;
        }[] | undefined;
        deltaSync?: boolean | undefined;
        userAgent?: string | undefined;
        triggerEventType?: ConfigTargetingTriggerEventType | undefined;
        appState?: ConfigTargetingAppState | undefined;
        locale?: string | undefined;
        deviceId?: string | undefined;
        userId?: string | undefined;
        clientIp?: string | undefined;
        isUnAuthorized?: boolean | undefined;
        appLocale?: string | undefined;
        instrumentation?: ConfigTargetingInstrumentation | undefined;
        lastSuccessfulSync?: number | undefined;
        isLogout?: boolean | undefined;
        packageInstaller?: string | undefined;
        syncTriggerBlizzardSessionId?: string | undefined;
        syncExecutionBlizzardSessionId?: string | undefined;
        cofSyncTriggerDelayFromStartupMs?: number | undefined;
        cofSyncExecutionDelayFromStartupMs?: number | undefined;
        syncTriggerTime?: number | undefined;
        decoderEncoderAvailability?: {
            isSnapVp9DecoderAvailable?: boolean | undefined;
            isSnapAv1DecoderAvailable?: boolean | undefined;
        } | undefined;
        snapkitAppId?: string | undefined;
        lenscoreVersion?: number | undefined;
        ruid?: {
            type?: import("../../common/ruid").Ruid_Type | undefined;
            stringValue?: string | undefined;
            loggingIdValue?: string | undefined;
        } | undefined;
        configNames?: string[] | undefined;
        includeTestUserTreatments?: boolean | undefined;
        disableExposureLogging?: boolean | undefined;
        lensClusterOrig4?: number | undefined;
        clientId?: string | undefined;
    } & {
        configResultsEtag?: string | undefined;
        namespaces?: (Namespace[] & Namespace[] & Record<Exclude<keyof I["namespaces"], keyof Namespace[]>, never>) | undefined;
        ghostId?: string | undefined;
        countryCode?: string | undefined;
        screenWidth?: number | undefined;
        screenHeight?: number | undefined;
        connectivity?: ({
            networkType?: Connectivity_NetworkType | undefined;
            isMetered?: boolean | undefined;
            isRoaming?: boolean | undefined;
            carrier?: string | undefined;
        } & {
            networkType?: Connectivity_NetworkType | undefined;
            isMetered?: boolean | undefined;
            isRoaming?: boolean | undefined;
            carrier?: string | undefined;
        } & Record<Exclude<keyof I["connectivity"], keyof Connectivity>, never>) | undefined;
        maxVideoWidthPx?: number | undefined;
        maxVideoHeightPx?: number | undefined;
        benchmarkResults?: ({
            name?: import("./benchmark_name").BenchmarkName | undefined;
            value?: {
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } | undefined;
        }[] & ({
            name?: import("./benchmark_name").BenchmarkName | undefined;
            value?: {
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } | undefined;
        } & {
            name?: import("./benchmark_name").BenchmarkName | undefined;
            value?: ({
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } & {
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } & Record<Exclude<keyof I["benchmarkResults"][number]["value"], keyof import("./benchmark").BenchmarkValue>, never>) | undefined;
        } & Record<Exclude<keyof I["benchmarkResults"][number], keyof BenchmarkResult>, never>)[] & Record<Exclude<keyof I["benchmarkResults"], keyof {
            name?: import("./benchmark_name").BenchmarkName | undefined;
            value?: {
                intValue?: number | undefined;
                longValue?: number | undefined;
                boolValue?: boolean | undefined;
                floatValue?: number | undefined;
            } | undefined;
        }[]>, never>) | undefined;
        deltaSync?: boolean | undefined;
        userAgent?: string | undefined;
        triggerEventType?: ConfigTargetingTriggerEventType | undefined;
        appState?: ConfigTargetingAppState | undefined;
        locale?: string | undefined;
        deviceId?: string | undefined;
        userId?: string | undefined;
        clientIp?: string | undefined;
        isUnAuthorized?: boolean | undefined;
        appLocale?: string | undefined;
        instrumentation?: ConfigTargetingInstrumentation | undefined;
        lastSuccessfulSync?: number | undefined;
        isLogout?: boolean | undefined;
        packageInstaller?: string | undefined;
        syncTriggerBlizzardSessionId?: string | undefined;
        syncExecutionBlizzardSessionId?: string | undefined;
        cofSyncTriggerDelayFromStartupMs?: number | undefined;
        cofSyncExecutionDelayFromStartupMs?: number | undefined;
        syncTriggerTime?: number | undefined;
        decoderEncoderAvailability?: ({
            isSnapVp9DecoderAvailable?: boolean | undefined;
            isSnapAv1DecoderAvailable?: boolean | undefined;
        } & {
            isSnapVp9DecoderAvailable?: boolean | undefined;
            isSnapAv1DecoderAvailable?: boolean | undefined;
        } & Record<Exclude<keyof I["decoderEncoderAvailability"], keyof DecoderEncoderAvailablity>, never>) | undefined;
        snapkitAppId?: string | undefined;
        lenscoreVersion?: number | undefined;
        ruid?: ({
            type?: import("../../common/ruid").Ruid_Type | undefined;
            stringValue?: string | undefined;
            loggingIdValue?: string | undefined;
        } & {
            type?: import("../../common/ruid").Ruid_Type | undefined;
            stringValue?: string | undefined;
            loggingIdValue?: string | undefined;
        } & Record<Exclude<keyof I["ruid"], keyof Ruid>, never>) | undefined;
        configNames?: (string[] & string[] & Record<Exclude<keyof I["configNames"], keyof string[]>, never>) | undefined;
        includeTestUserTreatments?: boolean | undefined;
        disableExposureLogging?: boolean | undefined;
        lensClusterOrig4?: number | undefined;
        clientId?: string | undefined;
    } & Record<Exclude<keyof I, keyof ConfigTargetingRequest>, never>>(object: I): ConfigTargetingRequest;
};
export declare const Connectivity: {
    encode(message: Connectivity, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Connectivity;
    fromPartial<I extends {
        networkType?: Connectivity_NetworkType | undefined;
        isMetered?: boolean | undefined;
        isRoaming?: boolean | undefined;
        carrier?: string | undefined;
    } & {
        networkType?: Connectivity_NetworkType | undefined;
        isMetered?: boolean | undefined;
        isRoaming?: boolean | undefined;
        carrier?: string | undefined;
    } & Record<Exclude<keyof I, keyof Connectivity>, never>>(object: I): Connectivity;
};
export declare const DecoderEncoderAvailablity: {
    encode(message: DecoderEncoderAvailablity, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DecoderEncoderAvailablity;
    fromPartial<I extends {
        isSnapVp9DecoderAvailable?: boolean | undefined;
        isSnapAv1DecoderAvailable?: boolean | undefined;
    } & {
        isSnapVp9DecoderAvailable?: boolean | undefined;
        isSnapAv1DecoderAvailable?: boolean | undefined;
    } & Record<Exclude<keyof I, keyof DecoderEncoderAvailablity>, never>>(object: I): DecoderEncoderAvailablity;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & Record<Exclude<keyof I, KeysOfUnion<P>>, never>;
export {};
