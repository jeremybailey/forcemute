import { defineAction, defineActions, defineState, defineStates, dispatch, forActions, inStates, StateMachine, } from "@snap/state-management";
import { catchError, from, map, merge, of, switchMap } from "rxjs";
import { Injectable } from "../dependency-injection/Injectable";
import { LegalDocument, LegalDocument_Type, LegalPrompt as LegalPromptProto, } from "../generated-proto/pb_schema/camera_kit/v3/legal_prompt";
import { getLogger } from "../logger/logger";
import { ExpiringPersistence } from "../persistence/ExpiringPersistence";
import { IndexedDBPersistence } from "../persistence/IndexedDBPersistence";
import { remoteConfigurationFactory } from "../remote-configuration/remoteConfiguration";
import { legalPromptFactory } from "./legalPrompt";
const logger = getLogger("LegalState");
/**
 * We store a hash of the last accepted ToS content. This is how we determine if the user previously accepted the
 * relevant ToS.
 *
 * ToS acceptance is only valid for 12 hours. That is, if legal status is checked and the last acceptance occurred more
 * than 12 hours ago, the user must be prompted to accept again.
 */
const tosContentHashExpiry = 12 * 60 * 60;
const tosContentHashKey = "lastAcceptedTosContentHash";
/**
 * Fast, simple hashing function from github.com/bryc
 * https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
 */
const computeHash = (str) => {
    let h1 = 0xdeadbeef;
    let h2 = 0x41c6ce57;
    for (let i = 0; i < str.length; i++) {
        const ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(16);
};
const createLegalState = () => {
    const states = defineStates(defineState("unknown")(), defineState("accepted")(), defineState("rejected")());
    const actions = defineActions(defineAction("requestLegalPrompt")(), defineAction("accept")(), defineAction("reject")());
    return new StateMachine(actions, states, states.unknown(), (actions) => {
        return merge(actions.pipe(inStates("unknown"), forActions("accept"), map(() => states.accepted())), actions.pipe(inStates("unknown"), forActions("reject"), map(() => states.rejected())), actions.pipe(forActions("requestLegalPrompt"), map(() => states.unknown())));
    });
};
const defaultLegalDocumentDate = new Date("2021-09-30T00:00:00+00:00");
const defaultLegalPrompt = LegalPromptProto.fromPartial({
    documents: [
        LegalDocument.fromPartial({
            type: LegalDocument_Type.PRIVACY_POLICY,
            webUrl: "https://values.snap.com/privacy/privacy-policy",
            version: "1",
            timestamp: defaultLegalDocumentDate,
        }),
        LegalDocument.fromPartial({
            type: LegalDocument_Type.TERMS_OF_SERVICE,
            webUrl: "https://snap.com/terms",
            version: "1",
            timestamp: defaultLegalDocumentDate,
        }),
        LegalDocument.fromPartial({
            type: LegalDocument_Type.LEARN_MORE,
            webUrl: "https://support.snapchat.com/article/camera-information-use",
            version: "1",
            timestamp: defaultLegalDocumentDate,
        }),
    ],
    disabled: false,
});
const hasAnyValue = (c) => {
    var _a, _b;
    return ((_b = (_a = c.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
const getDocumentOrDefault = (documents) => (type) => {
    var _a;
    return ((_a = documents.find((d) => d.type === type)) !== null && _a !== void 0 ? _a : defaultLegalPrompt.documents.find((d) => d.type === type));
};
/**
 * We maintain the state of the user's acceptance of Snap's various legal documents. Other components may require that
 * the legal state be "accepted" before proceeding (e.g. to apply a lens).
 *
 * On page load, the legal state starts as "unknown." If a request is made to determine the legal state, the following
 * business logic is implemented:
 *
 * 1. Download remote COF config value containing the legal documents + a `disabled` field to optionally skip the legal
 * requirement.
 * 2. Check for a `lastAcceptedTosContentHash` stored in IndexedDB.
 * 3. Prompt the user to accept/reject the legal documents.
 *
 *                     ┌────────────────────────────────────────────────────────┐
 *                     │       COF config value includes "disabled: true"       │
 *                     └────────────────────────────────────────────────────────┘
 *                                                  │
 *                                                  │
 *                           ┌────────No────────────┴────────────Yes──────────────────┐
 *                           │                                                        │
 *                           ▼                                                        │
 *        ┌────────────────────────────────────┐                                      ▼
 *        │"lastAcceptedTosContentHash" exists │                               ┌────────────┐
 *        └────────────────────────────────────┘                               │  Skip ToS  │
 *                           │                                                 └────────────┘
 *                           │                                                        ▲
 *        ┌─────────────No───┴───────Yes────────────┐                                 │
 *        │                                         │                                 │
 *        │                                         │                                 │
 *        ▼                                         ▼                                 │
 * ┌────────────┐              ┌────────────────────────────────────────┐             │
 * │  Show ToS  │              │  Hash of ToS content from COF matches  │             │
 * └────────────┘              │      "lastAcceptedTosContentHash"      │             │
 *        ▲                    └────────────────────────────────────────┘             │
 *        │                                         │                                 │
 *        │                                         │                                 │
 *        └──────────────────No─────────────────────┴───────────────────Yes───────────┘
 *
 * @internal
 */
export const legalStateFactory = Injectable("legalState", [remoteConfigurationFactory.token, legalPromptFactory.token], (remoteConfig, legalPrompt) => {
    const persistance = new ExpiringPersistence(() => tosContentHashExpiry, new IndexedDBPersistence({ databaseName: "Legal" }));
    const getLastAcceptedTosContentHash = () => from(persistance.retrieve(tosContentHashKey).catch((error) => logger.warn(error)));
    const setLastAcceptedTosContentHash = (hash) => persistance.store(tosContentHashKey, hash).catch((error) => logger.warn(error));
    const legalState = createLegalState();
    legalState.events
        .pipe(inStates("unknown", "rejected"), forActions("requestLegalPrompt"), switchMap(() => remoteConfig.get("CAMERA_KIT_LEGAL_PROMPT").pipe(map((configResults) => {
        const config = configResults.find(hasAnyValue);
        if (!config)
            return defaultLegalPrompt;
        return LegalPromptProto.decode(config.value.anyValue.value);
    }), catchError((error) => {
        logger.error(error);
        return of(defaultLegalPrompt);
    }))), switchMap((config) => {
        if (config.disabled)
            return of(legalState.actions.accept("disabled"));
        const currentTosContentHash = computeHash(JSON.stringify(config.documents));
        return getLastAcceptedTosContentHash().pipe(switchMap((lastAcceptedTosContentHash) => {
            if (currentTosContentHash === lastAcceptedTosContentHash)
                return of(true);
            // Delegate prompting the end-user to accept/reject the legal documents. This returns with
            // an Observable<boolean> indicating accept/reject.
            const documentOfType = getDocumentOrDefault(config.documents);
            return legalPrompt(documentOfType(LegalDocument_Type.PRIVACY_POLICY), documentOfType(LegalDocument_Type.TERMS_OF_SERVICE), documentOfType(LegalDocument_Type.LEARN_MORE));
        }), map((didAccept) => {
            if (!didAccept)
                return legalState.actions.reject(currentTosContentHash);
            setLastAcceptedTosContentHash(currentTosContentHash);
            return legalState.actions.accept(currentTosContentHash);
        }));
    }), dispatch(legalState))
        .subscribe();
    return legalState;
});
//# sourceMappingURL=legalState.js.map