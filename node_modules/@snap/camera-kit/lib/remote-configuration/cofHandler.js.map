{"version":3,"file":"cofHandler.js","sourceRoot":"","sources":["../../src/remote-configuration/cofHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { BrowserHeaders } from \"browser-headers\";\nimport { cameraKitUserAgent } from \"../common/cameraKitUserAgent\";\nimport { ensureError } from \"../common/errorHelpers\";\nimport { CircumstancesServiceClientImpl, GrpcWebImpl } from \"../generated-proto/pb_schema/cdp/cof/circumstance_service\";\nimport { ConfigTargetingRequest } from \"../generated-proto/pb_schema/cdp/cof/config_request\";\nimport { ConfigTargetingResponse } from \"../generated-proto/pb_schema/cdp/cof/config_response\";\nimport { ChainableHandler, HandlerChainBuilder, RequestMetadata } from \"../handlers/HandlerChainBuilder\";\nimport {\n    dispatchRequestCompleted,\n    dispatchRequestErrored,\n    dispatchRequestStarted,\n} from \"../handlers/requestStateEmittingHandler\";\nimport { createResponseCachingHandler, staleWhileRevalidateStrategy } from \"../handlers/responseCachingHandler\";\nimport { createRetryingHandler } from \"../handlers/retryingHandler\";\nimport { createTimeoutHandler } from \"../handlers/timeoutHandler\";\nimport { ExpiringPersistence } from \"../persistence/ExpiringPersistence\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\n\ninterface Metadata {\n    [key: string]: string;\n}\n\nconst id = <Req, Res, Meta extends RequestMetadata>(h: ChainableHandler<Req, Res, Req, Res, Meta>) => h;\n\n// We need to wrap `targetingQuery` to create a usable Handler – the main issue is that HandlerChainBuilder always adds\n// a `signal` property to the metadata argument (second argument of the Handler), but `targetingQuery` expects the\n// second argument to only contain headers.\nconst createTargetingQueryHandler =\n    (apiToken: string) =>\n    async (request: Partial<ConfigTargetingRequest>, { signal, ...metadata }: Metadata & RequestMetadata) => {\n        const rpc = new GrpcWebImpl(\"https://api-kit.snapchat.com\", {});\n        const client = new CircumstancesServiceClientImpl(rpc);\n        return new Promise<ConfigTargetingResponse>((resolve, reject) => {\n            if (signal) {\n                signal.addEventListener(\"abort\", () => reject(new Error(\"COF request aborted by handler chain.\")));\n            }\n            client\n                .targetingQuery(\n                    request,\n                    new BrowserHeaders({\n                        authorization: `Bearer ${apiToken}`,\n                        \"x-snap-client-user-agent\": cameraKitUserAgent.userAgent,\n                        ...metadata,\n                    })\n                )\n                .then((response) => {\n                    // NOTE: in order for cache persistance to work, we need to make the object cloneable,\n                    // i.e. with no methods (it appears targetingQuery() attaches toObject() to response object).\n                    // Safety: We have to cast response object to a type that has toObject defined, because that is\n                    // indeed what generated code has:\n                    // eslint-disable-next-line max-len\n                    // https://github.sc-corp.net/Snapchat/camera-kit-web-sdk/blob/8d6b4e8bfa3717b376ab197a49972a1e410851f7/packages/web-sdk/src/generated-proto/pb_schema/cdp/cof/circumstance_service.ts#L1459\n                    delete (response as any).toObject;\n                    resolve(response);\n                })\n                .catch(reject);\n        });\n    };\n\nexport const COF_REQUEST_TYPE = \"cof\";\n\nexport type CofDimensions = { requestType: typeof COF_REQUEST_TYPE };\n\n/**\n * Handler chain used to make COF requests. Uses the COF client to perform the\n * requests, with retries, timeout, and caching.\n *\n * The handler will first attempt to retrieve the COF response from cache. If it is found, the result is returned\n * immediately and the cache is updated in the background. If no response is found, a COF request is made. This request\n * will retry (with exponential backoff + jitter) for 5 seconds before returning an error to the caller.\n */\nexport const cofHandlerFactory = (apiToken: string) =>\n    new HandlerChainBuilder(createTargetingQueryHandler(apiToken))\n        .map(\n            id((next) => async (request, metadata) => {\n                const dimensions: CofDimensions = { requestType: COF_REQUEST_TYPE };\n                const { requestId } = dispatchRequestStarted({ dimensions });\n                try {\n                    const response = await next(request, metadata);\n                    // TODO: We hardcode status code and sizeByte values because we do not have access to underlying\n                    // transport of configs-web.\n                    // When this ticket is done https://jira.sc-corp.net/browse/CAMKIT-2840,\n                    // we will remove this handler and benefit from existing ones.\n                    const status = 200;\n                    let sizeByte = 0;\n                    try {\n                        sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;\n                    } finally {\n                        dispatchRequestCompleted({ requestId, dimensions, status, sizeByte });\n                        return response;\n                    }\n                } catch (error) {\n                    dispatchRequestErrored({ requestId, dimensions, error: ensureError(error) });\n                    throw error;\n                }\n            })\n        )\n        // targetingQuery() always converts failed responses into errors (unlike fetch()), so we need a custom\n        // retryPredicate that retries all errors. We'll keep retrying (with backoff) for 20 seconds total elapsed\n        // time before we return an error back up the chain.\n        .map(createRetryingHandler({ retryPredicate: (r) => r instanceof Error }))\n        // API gateway has 15 seconds timeout, so we rely on that first\n        .map(createTimeoutHandler({ timeout: 20 * 1000 }))\n        .map(\n            createResponseCachingHandler(\n                // COF responses will be removed from cache after 1 week. Keep in mind that the staleWhileRevalidate\n                // strategy will update the cache each time COF is requested – this expiration comes into play only if\n                // e.g. a user doesn't load the page for more than a week.\n                new ExpiringPersistence<ConfigTargetingResponse>(\n                    () => 7 * 24 * 60 * 60,\n                    new IndexedDBPersistence({ databaseName: \"COFCache\" })\n                ),\n                (r: Partial<ConfigTargetingRequest>) => JSON.stringify(r),\n\n                // If we have a matching response already in cache, we'll return it immediately and then update the\n                // cache in the background.\n                staleWhileRevalidateStrategy()\n            )\n        ).handler;\n"]}