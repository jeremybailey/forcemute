import { __awaiter } from "tslib";
import { Injectable } from "../../dependency-injection/Injectable";
import { lensAssetError } from "../../namedErrors";
import { lensCoreFactory } from "../../lens-core-module";
import { getLogger } from "../../logger/logger";
import { toPublicLens } from "../Lens";
import { lensRepositoryFactory } from "../LensRepository";
import { lensAssetRepositoryFactory } from "./LensAssetRepository";
const logger = getLogger("LensAssetProvider");
/**
 * Registers a remote asset provider function with a given instance of LensCore.
 *
 * *Note:* LensCoreModule.initialize must be called on the desired LensCoreModule instance **prior** to passing it
 * to the LensAssetsProvider constructor. If this class is instantiated with a LensCoreModule that has not been
 * initialized, the registry of the asset provider function will fail silently and no remote assets will be loaded.
 * @internal
 */
export const registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [lensCoreFactory.token, lensRepositoryFactory.token, lensAssetRepositoryFactory.token], (lensCore, lensRepository, lensAssetRepository) => {
    lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        // Fetch an asset and provide it to LensCore. If fetching the asset fails we give LensCore
        // an empty response (which it may handle in a variety of ways, e.g. retry, gracefully
        // degrade lens behavior, throw error) and then reject.
        const { assetId, assetType, effectId } = assetDescriptor;
        try {
            const lens = effectId ? lensRepository.getLensMetadata(effectId) : undefined;
            yield lensAssetRepository.loadAsset(assetDescriptor, lens && toPublicLens(lens), (_a = lens === null || lens === void 0 ? void 0 : lens.content) === null || _a === void 0 ? void 0 : _a.assetManifest);
        }
        catch (error) {
            // if an error occurs, LensCore handles things in different ways
            // depending on the active lens. It might: 1) retry, 2) gracefully degrade lens behavior,
            // 3) lens JS might throw, which will be passed to the exceptionHandler we register with LensCore.
            lensCore.provideRemoteAssetsResponse({
                assetId,
                assetType,
            });
            logger.error(lensAssetError(`Unable to handle lens asset "${assetId}" request.`, error));
        }
    }));
});
//# sourceMappingURL=LensAssetsProvider.js.map