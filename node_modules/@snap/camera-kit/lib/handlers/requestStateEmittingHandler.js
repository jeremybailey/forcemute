import { __awaiter } from "tslib";
import { ensureError } from "../common/errorHelpers";
import { getTimeMs } from "../common/time";
import { TypedCustomEvent } from "../events/TypedCustomEvent";
import { TypedEventTarget } from "../events/TypedEventTarget";
let requestId = 0;
const safeParseInt = (str) => {
    if (str == null)
        return 0;
    const maybeInt = parseInt(str);
    return isNaN(maybeInt) ? 0 : maybeInt;
};
export const requestStateEventTarget = new TypedEventTarget();
export const dispatchRequestStarted = (data) => {
    const started = Object.assign(Object.assign({}, data), { requestId: requestId++, timeMs: getTimeMs() });
    requestStateEventTarget.dispatchEvent(new TypedCustomEvent("started", started));
    return started;
};
export const dispatchRequestCompleted = (data) => {
    const completed = Object.assign(Object.assign({}, data), { timeMs: getTimeMs() });
    requestStateEventTarget.dispatchEvent(new TypedCustomEvent("completed", completed));
    return completed;
};
export const dispatchRequestErrored = (data) => {
    const errored = Object.assign(Object.assign({}, data), { timeMs: getTimeMs() });
    requestStateEventTarget.dispatchEvent(new TypedCustomEvent("errored", errored));
    return errored;
};
export const createRequestStateEmittingHandler = () => (next) => ([request, dimensions], metadata) => __awaiter(void 0, void 0, void 0, function* () {
    const { requestId } = dispatchRequestStarted({ dimensions });
    try {
        const response = yield next(request, metadata);
        const status = response.status;
        const sizeByte = safeParseInt(response.headers.get("content-length"));
        dispatchRequestCompleted({ requestId, dimensions, status, sizeByte });
        return response;
    }
    catch (error) {
        dispatchRequestErrored({ requestId, dimensions, error: ensureError(error) });
        throw error;
    }
});
//# sourceMappingURL=requestStateEmittingHandler.js.map