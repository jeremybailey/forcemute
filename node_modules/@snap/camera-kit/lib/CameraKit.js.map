{"version":3,"file":"CameraKit.js","sourceRoot":"","sources":["../src/CameraKit.ts"],"names":[],"mappings":"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","sourcesContent":["import { lensRepositoryFactory, LensRepository } from \"./lens/LensRepository\";\nimport { CONTAINER, Container } from \"./dependency-injection/Container\";\nimport { Injectable } from \"./dependency-injection/Injectable\";\nimport { LensCoreError, LensCoreModule } from \"./lens-core-module/generated-types\";\nimport { CameraKitSession, cameraKitSessionFactory } from \"./session/CameraKitSession\";\nimport { registerLensAssetsProvider } from \"./lens/assets/LensAssetsProvider\";\nimport { lensCoreFactory } from \"./lens-core-module/loader/lensCoreFactory\";\nimport { configurationToken } from \"./configuration\";\nimport { RootServices } from \"./dependency-injection/RootServices\";\nimport { registerUriHandlers } from \"./extensions/UriHandlers\";\nimport { MetricsEventTarget, metricsEventTargetFactory } from \"./metrics/metricsEventTarget\";\nimport { reportSessionScopedMetrics } from \"./metrics/reporters/reporters\";\nimport { lensStateFactory } from \"./session/lensState\";\nimport { lensKeyboardFactory } from \"./session/LensKeyboard\";\nimport { registerLensClientInterfaceHandler } from \"./lens-client-interface/lensClientInterface\";\nimport { sessionStateFactory } from \"./session/sessionState\";\nimport { lensExecutionError } from \"./namedErrors\";\nimport { getLogger } from \"./logger/logger\";\nimport { errorLoggingDecorator } from \"./logger/errorLoggingDecorator\";\nimport { TypedEventTarget } from \"./events/TypedEventTarget\";\nimport { TypedCustomEvent } from \"./events/TypedCustomEvent\";\nimport { LensView } from \"./metrics/reporters/reportLensView\";\nimport { LensWait } from \"./metrics/reporters/reportLensWait\";\n\nconst logger = getLogger(\"CameraKit\");\nconst log = errorLoggingDecorator(logger);\n\n/**\n * Metrics event names that are exposed to apps.\n */\nconst publicMetricsEventNames: Array<LensMetricsEvents[\"detail\"][\"name\"]> = [\"lensView\", \"lensWait\"];\n\n/**\n * Lens metrics events.\n *\n * These events are emitted by {@link CameraKit} to report lens usage, performance, apply latency, etc.\n *\n * @category Lenses\n * @category Metrics\n */\nexport type LensMetricsEvents =\n    | TypedCustomEvent<LensView[\"name\"], LensView>\n    | TypedCustomEvent<LensWait[\"name\"], LensWait>;\n\n/**\n * Options available when creating a {@link CameraKitSession}.\n *\n * @category Rendering\n */\nexport interface CreateSessionOptions {\n    /**\n     * Optionally provide an existing canvas element, on which the Live RenderTarget will be rendered.\n     *\n     * If this is not provided, CameraKit will create a new canvas element which can be added to the DOM.\n     */\n    liveRenderTarget?: HTMLCanvasElement;\n\n    /**\n     * Browsers optimize tabs when they are hidden - for example, by pausing the execution of requestAnimationFrame\n     * callbacks.\n     *\n     * If you need the CameraKitSession to continue rendering even when the tab is in the background, set this to true.\n     * There is a small performance penalty, and it's a good practice to only render in the background if absolutely\n     * necessary.\n     */\n    renderWhileTabHidden?: boolean;\n}\n\n/**\n * The entry point to the CameraKit SDK's API. Most of CameraKit's features are accessed via this class.\n *\n * Applications obtain an instance of CameraKit by calling {@link bootstrapCameraKit}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(config)\n * ```\n *\n * Then this class can be used to:\n * - Create a {@link CameraKitSession} instance, which provides the API for setting up media inputs, applying Lenses,\n * and obtaining rendered `<canvas>` outputs.\n * - Query for lenses using {@link LensRepository}.\n * - Listen for lens usage metrics events using {@link MetricsEventTarget}.\n *\n * @category Rendering\n * @category Lenses\n */\nexport class CameraKit {\n    /** @deprecated Use {@link lensRepository} */\n    readonly lenses: { repository: LensRepository };\n\n    /**\n     * Business metrics (e.g. each time a lens is viewed) are emitted here.\n     */\n    readonly metrics: TypedEventTarget<LensMetricsEvents> = new TypedEventTarget();\n\n    /** @internal */\n    constructor(\n        /**\n         * Used to query for lenses and lens groups.\n         */\n        readonly lensRepository: LensRepository,\n\n        private readonly lensCore: LensCoreModule,\n        private readonly container: Container<RootServices>,\n        allMetrics: MetricsEventTarget\n    ) {\n        this.lenses = { repository: this.lensRepository };\n        // Proxy only a subset of all metrics events to the public-facing emitter -- applications don't need to\n        // know about most events.\n        publicMetricsEventNames.forEach((eventName) => {\n            allMetrics.addEventListener(eventName, (e) => this.metrics.dispatchEvent(e));\n        });\n    }\n\n    /**\n     * Create a CameraKitSession.\n     *\n     * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access\n     * to Lens rendering.\n     *\n     * @example\n     * ```ts\n     * const cameraKit = await bootstrapCameraKit(config)\n     * const session = await cameraKit.createSession()\n     *\n     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n     * session.applyLens(lens)\n     * ```\n     *\n     * @param options\n     */\n    @log\n    async createSession({\n        liveRenderTarget,\n        renderWhileTabHidden,\n    }: CreateSessionOptions = {}): Promise<CameraKitSession> {\n        // Any error happened during lens rendering can be processed by subscribing to sessionErrors\n        const exceptionHandler = (e: LensCoreError) => logger.error(lensExecutionError(\"Lens execution error.\", e));\n\n        /**\n         * If/when we add support for multiple concurrent sessions, we'll need to create a copy of the LensCore WASM\n         * module. If we move managing web workers into JS, spawing a new worker thread with its own copy of LensCore\n         * probably becomes a lot more straightforward.\n         *\n         * Currently chromium has a bug preventing rendering while tab is hidden when LensCore is in worker mode.\n         * In order to process tab while it is hidden, the current stopgap is to pass in renderWhileTabHidden as true,\n         * which will initiate session in non worker mode, and set the RenderLoopMode to `SetTimeout`.\n         */\n        await new Promise<void>((onSuccess, onFailure) => {\n            this.lensCore.initialize({\n                canvas: liveRenderTarget,\n                shouldUseWorker: !renderWhileTabHidden && this.container.get(configurationToken).shouldUseWorker,\n                exceptionHandler,\n                onSuccess,\n                onFailure,\n            });\n        });\n\n        await new Promise<void>((onSuccess, onFailure) => {\n            this.lensCore.setRenderLoopMode({\n                mode: renderWhileTabHidden\n                    ? this.lensCore.RenderLoopMode.SetTimeout\n                    : this.lensCore.RenderLoopMode.RequestAnimationFrame,\n                onSuccess,\n                onFailure,\n            });\n        });\n\n        // Each session gets its own DI Container â€“ some Services provided by this Container may be shared with the\n        // root CameraKit Container, but others may be scoped to the session by passing their token to `copy()`.\n        const sessionContainer = this.container\n            // Right now this is a no-op. If/when we add support for multiple concurrent sessions, we may end up\n            // scoping LensCore to the session.\n            .copy()\n\n            .provides(sessionStateFactory)\n            .provides(lensStateFactory)\n            .provides(lensKeyboardFactory)\n            .provides(cameraKitSessionFactory)\n\n            .run(registerLensAssetsProvider)\n            .run(registerLensClientInterfaceHandler)\n\n            // We'll run a PartialContainer containing reporters for session-scoped metrics. Running this container\n            // allows each metric reporter to initialize itself (e.g. by adding event listeners to detect when certain\n            // actions occur).\n            .run(reportSessionScopedMetrics)\n\n            // UriHandlers may have dependencies on session-scoped services (e.g. LensState, LensKeyboard), so they'll\n            // be registered with LensCore here.\n            .run(registerUriHandlers);\n\n        return sessionContainer.get(cameraKitSessionFactory.token);\n    }\n}\n\n/** @internal */\nexport const cameraKitFactory = Injectable(\n    \"CameraKit\",\n    [lensRepositoryFactory.token, metricsEventTargetFactory.token, lensCoreFactory.token, CONTAINER] as const,\n    (\n        lensRepository: LensRepository,\n        metrics: MetricsEventTarget,\n        lensCore: LensCoreModule,\n        container: Container<RootServices>\n    ) => new CameraKit(lensRepository, lensCore, container, metrics)\n);\n"]}