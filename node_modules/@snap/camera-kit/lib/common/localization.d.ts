/**
 * This implementation is limited by how TypeScript currently implements tag function for template literals.
 *
 * The way tag functions are typed by the TypeScript compiler limits their usefulness, for two reasons:
 *
 * 1. Specific literal types are not inferred from interpolation expressions -- the following does not work:
 * ```ts
 * function tag<K extends readonly string[]>(strings: readonly string[], ...keys: K): string { ... }
 * tag`This is a ${"test"} template.` // the K type parameter is not correctly inferred as `readonly ['test']`
 * ```
 * 2. The return type of a function used as a tag function will always be `string` -- the following does not work:
 * ```ts
 * function tag<K extends readonly string[]>(
 *   strings: readonly string[],
 *   ...keys: K
 * ): (values: {[k in K[number]]: string}) => string { ... }
 *
 * const template = tag`This is a ${"test"} template` // TS infers the type of `template` as `string` -- clearly wrong.
 * ```
 *
 * An attempt is made here to work around those limitations and still provide a reasonably amount of type safety without
 * adding too much verbosity.
 *
 * See https://github.com/microsoft/TypeScript/pull/49552
 */
/**
 * We use the en_US string object to define all localizable stringIds and their types (either a TemplateFunction or a
 * plain string).
 */
type LocalizableStrings = typeof en_US;
type TemplateFunction<K extends readonly string[], V extends {
    [key in K[number]]: string;
}> = (values: V) => string;
/**
 * Strings for each language are defined blow.
 */
declare const en_US: {
    legalPromptMessage: TemplateFunction<readonly ["privacyPolicyUrl", "termsOfServiceUrl", "learnMoreUrl"], {
        privacyPolicyUrl: string;
        termsOfServiceUrl: string;
        learnMoreUrl: string;
    }>;
    legalPromptAccept: string;
    legalPromptReject: string;
};
export declare function localizedString<ID extends keyof LocalizableStrings>(stringId: ID): LocalizableStrings[ID];
export {};
