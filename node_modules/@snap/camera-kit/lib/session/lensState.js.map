{"version":3,"file":"lensState.js","sourceRoot":"","sources":["../../src/session/lensState.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    Actions,\n    defineAction,\n    defineActions,\n    defineState,\n    defineStates,\n    dispatch,\n    forActions,\n    inStates,\n    StateMachine,\n} from \"@snap/state-management\";\nimport {\n    catchError,\n    exhaustMap,\n    from,\n    map,\n    merge,\n    mergeMap,\n    Observable,\n    of,\n    switchMap,\n    take,\n    takeUntil,\n    tap,\n} from \"rxjs\";\nimport { ensureError } from \"../common/errorHelpers\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { Lens } from \"../lens/Lens\";\nimport { LensRepository, lensRepositoryFactory } from \"../lens/LensRepository\";\nimport { lensCoreFactory, LensCoreModule } from \"../lens-core-module\";\nimport { AddLensInput } from \"../lens-core-module/generated-types\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport { lensPersistenceStoreFactory } from \"../lens/LensPersistenceStore\";\nimport { createLaunchData, LensLaunchParams } from \"../lens/LensLaunchParams\";\nimport { LegalState, legalStateFactory } from \"../legal/legalState\";\nimport { LensAssetRepository, lensAssetRepositoryFactory } from \"../lens/assets/LensAssetRepository\";\nimport {\n    legalError,\n    LegalError,\n    lensContentValidationError,\n    LensContentValidationError,\n    lensError,\n    LensError,\n} from \"../namedErrors\";\nimport { getLogger } from \"../logger/logger\";\n\nconst logger = getLogger(\"LensState\");\n\nconst createLensState = () => {\n    const actions = defineActions(\n        defineAction(\"applyLens\")<{ lens: Lens; launchParams?: LensLaunchParams }>(),\n        defineAction(\"downloadComplete\")<Lens>(),\n        defineAction(\"turnedOn\")<Lens>(),\n        defineAction(\"resourcesLoaded\")<Lens>(),\n        defineAction(\"firstFrameProcessed\")<Lens>(),\n        defineAction(\"applyLensComplete\")<Lens>(),\n        defineAction(\"applyLensFailed\")<{ error: LensErrors; lens: Lens }>(),\n\n        defineAction(\"removeLens\")(),\n        defineAction(\"turnedOff\")<Lens>(),\n        defineAction(\"removeLensComplete\")(),\n        defineAction(\"removeLensFailed\")<Error>()\n    );\n\n    const states = defineStates(\n        defineState(\"noLensApplied\")(),\n        defineState(\"applyingLens\")<Lens>(),\n        defineState(\"lensApplied\")<Lens>()\n    );\n\n    return new StateMachine(actions, states, states.noLensApplied(), (events) =>\n        merge(\n            events.pipe(\n                // We allow a new lens to be applied at any time, no matter the state.\n                inStates(\"noLensApplied\", \"applyingLens\", \"lensApplied\"),\n                forActions(\"applyLens\"),\n                map(([a]) => states.applyingLens(a.data.lens))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensComplete\"),\n                map(([a]) => states.lensApplied(a.data))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensFailed\"),\n                map(() => states.noLensApplied())\n            ),\n            events.pipe(\n                inStates(\"lensApplied\"),\n                forActions(\"removeLensComplete\"),\n                map(() => states.noLensApplied())\n            )\n        )\n    );\n};\n\nexport type LensErrors = LegalError | LensContentValidationError | LensError;\n\nexport type LensState = ReturnType<typeof createLensState>;\n\nexport const lensStateFactory = Injectable(\n    \"lensState\",\n    [\n        lensCoreFactory.token,\n        lensRepositoryFactory.token,\n        lensAssetRepositoryFactory.token,\n        lensPersistenceStoreFactory.token,\n        legalStateFactory.token,\n    ] as const,\n    (\n        lensCore: LensCoreModule,\n        lensRepository: LensRepository,\n        lensAssetRepository: LensAssetRepository,\n        lensPersistence: IndexedDBPersistence<ArrayBuffer>,\n        legalState: LegalState\n    ): LensState => {\n        const lensState = createLensState();\n\n        /**\n         * Apply lens\n         */\n        lensState.events\n            .pipe(\n                forActions(\"applyLens\"),\n\n                // Determine the legal state (e.g. terms have been accepted). Using exhaustMap means while we are\n                // ascertaining legal status (which may include prompting the end user to accept terms), we will ignore\n                // any new applyLens actions.\n                exhaustMap(([a]) =>\n                    of(legalState.actions.requestLegalPrompt()).pipe(\n                        dispatch(legalState),\n                        inStates(\"accepted\", \"rejected\"),\n                        take(1),\n                        map(([, { name }]) => {\n                            if (name === \"accepted\") return a;\n                            return lensState.actions.applyLensFailed({\n                                error: legalError(\n                                    `Failed to apply lens ${a.data.lens.id}. Required legal terms were not ` +\n                                        `accepted.`\n                                ),\n                                lens: a.data.lens,\n                            });\n                        })\n                    )\n                ),\n\n                // The use of switchMap is important so that if we get a new applyLens action while we're still\n                // downloading lens content for a previously-requested lens, we can cancel those requests and ensure\n                // that lenses are applied in the order they're requested.\n                switchMap((a) => {\n                    if (a.name === \"applyLensFailed\") return of(a);\n\n                    const { lens } = a.data;\n\n                    // Convenience method making dispatching an action with Lens data less verbose.\n                    const dispatch = (action: Extract<Actions<LensState>, { data: Lens }>[\"name\"]) =>\n                        lensState.dispatch(action, lens);\n\n                    return of(a.data).pipe(\n                        mergeMap(({ lens, launchParams }) =>\n                            // If retrieval throws an error, we still want to proceed with the lens\n                            // because persisted data is not a necessity.\n                            from(lensPersistence.retrieve(lens.id).catch(() => undefined)).pipe(\n                                map((persistentStore) => ({ lens, launchParams, persistentStore }))\n                            )\n                        ),\n\n                        map(({ lens, launchParams, persistentStore }) => {\n                            const launchData = createLaunchData({\n                                launchParams,\n                                persistentStore,\n                            });\n\n                            const lensDetails = lensRepository.getLensMetadata(lens.id);\n                            if (!lensDetails) {\n                                throw new Error(\n                                    `Cannot apply lens ${lens.id}. It has not been loaded by the Lens repository. ` +\n                                        `Use CameraKit.lenses.repository.loadLens (or loadLensGroups) to load lens ` +\n                                        `metadata before calling CameraKitSession.applyLens.`\n                                );\n                            }\n\n                            const { content } = lensDetails;\n                            if (!content) {\n                                throw new Error(\n                                    `Cannot apply lens ${lens.id}. Metadata retrieved for this lens does not include ` +\n                                        `the lens content URL.`\n                                );\n                            }\n\n                            return { lens, launchData, content };\n                        }),\n\n                        // Load lens assets and the lens itself in parallel. Both count toward lens download time.\n                        // TODO: use RxJS fetch utilities so that these requests can be cancelled on unsubscribe.\n                        mergeMap(({ lens, launchData, content }) =>\n                            from(\n                                Promise.all([\n                                    lensRepository.getLensContent(lens),\n                                    lensAssetRepository.cacheAssets(content.assetManifest, lens),\n                                ])\n                            ).pipe(\n                                tap(() => lensState.dispatch(\"downloadComplete\", lens)),\n                                map(([{ lensBuffer, lensChecksum }]): AddLensInput => {\n                                    // NOTE: cached array buffer has to be copied each time in order to be reused,\n                                    // otherwise the original cached copy would be detached by LensCore\n                                    // One optimization can be done here: do not copy the array if getLensContent()\n                                    // returned uncached buffer\n                                    const lensDataBuffer = lensBuffer.slice(0);\n                                    // LensCore chokes trying if launchData is set to undefined; we must omit it.\n                                    return launchData === undefined\n                                        ? { lensId: lens.id, lensDataBuffer, lensChecksum }\n                                        : { lensId: lens.id, lensDataBuffer, lensChecksum, launchData };\n                                })\n                            )\n                        ),\n\n                        // If removeLens is dispatched while downloading, cancel download, don't apply the lens.\n                        takeUntil(lensState.events.pipe(forActions(\"removeLens\"))),\n\n                        // Once the lens has downloaded, we can call replaceLenses. We're not concerned about waiting\n                        // for prior in-progress calls to replaceLenses to complete, because LensCore guarantees that\n                        // calls to replaceLenses will always be processed sequentially in the order they are received.\n                        mergeMap(\n                            (lensInput) =>\n                                new Observable<Actions<LensState>>((subscriber) => {\n                                    // replaceLenses has the property that if it fails, LensCore guarantees that no\n                                    // lenses are active – so we can safely dispatch applyLensFailed and transition to\n                                    // noLensApplied state.\n                                    lensCore.replaceLenses({\n                                        lenses: [\n                                            {\n                                                ...lensInput,\n                                                onTurnOn: () => dispatch(\"turnedOn\"),\n                                                onResourcesLoaded: () => dispatch(\"resourcesLoaded\"),\n                                                onFirstFrameProcessed: () => dispatch(\"firstFrameProcessed\"),\n                                                onTurnOff: () => dispatch(\"turnedOff\"),\n                                            },\n                                        ],\n                                        onSuccess: () => {\n                                            // We emit applyLensComplete (and applyLensFailed, below) on an Observable,\n                                            // which is piped to `dispatch` – this allows `switchMap` to properly cancel\n                                            // the dispatch of these actions if a new applyLens arrives while we're\n                                            // waiting for onSuccess/onFailure.\n                                            //\n                                            // That's desirable behavior, because we don't want the applyingLens state\n                                            // due to a *subsequent applyLens action* to be transitioned to lensApplied\n                                            // by this action.\n                                            subscriber.next(lensState.actions.applyLensComplete(lens));\n                                            subscriber.complete();\n                                        },\n                                        onFailure: (reason) => {\n                                            const lensCoreError = ensureError(reason);\n                                            const message = `Failed to apply lens ${lensInput.lensId}.`;\n                                            const error = /validation failed/.test(lensCoreError.message)\n                                                ? lensContentValidationError(message, lensCoreError)\n                                                : lensError(message, lensCoreError);\n\n                                            subscriber.next(lensState.actions.applyLensFailed({ error, lens }));\n                                            subscriber.complete();\n                                        },\n                                    });\n                                })\n                        ),\n\n                        catchError((error: LensErrors) => of(lensState.actions.applyLensFailed({ error, lens })))\n                    );\n                }),\n                dispatch(lensState)\n            )\n            .subscribe();\n\n        /**\n         * Remove lens\n         */\n        lensState.events\n            .pipe(\n                inStates(\"lensApplied\", \"noLensApplied\"),\n                forActions(\"removeLens\"),\n                mergeMap(\n                    () =>\n                        new Observable<Actions<LensState>>((subscriber) => {\n                            lensCore.clearAllLenses({\n                                onSuccess: () => {\n                                    subscriber.next(lensState.actions.removeLensComplete());\n                                    subscriber.complete();\n                                },\n                                onFailure: (lensCoreError: unknown) => {\n                                    const error = new Error(\"Failed to remove lenses.\", { cause: lensCoreError });\n                                    subscriber.next(lensState.actions.removeLensFailed(error));\n                                    subscriber.complete();\n                                },\n                            });\n                        })\n                ),\n                dispatch(lensState)\n            )\n            .subscribe();\n\n        lensState.events\n            .pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"removeLens\"),\n                switchMap(([a]) =>\n                    lensState.events.pipe(\n                        // Wait to remove the lens until it has been applied.\n                        inStates(\"lensApplied\"),\n                        // But cancel the removal if a new applyLens supercedes the current lens. The goal here is to\n                        // make sure the latest apply/remove pre-empts any previous request to apply/remove.\n                        takeUntil(lensState.events.pipe(forActions(\"applyLens\"))),\n                        map(() => a)\n                    )\n                ),\n                dispatch(lensState)\n            )\n            .subscribe();\n\n        // Log transitions\n        lensState.events.subscribe(([a, s]) => logger.debug(`Action: \"${a.name}\", state: \"${s.name}\"`));\n\n        return lensState;\n    }\n);\n"]}