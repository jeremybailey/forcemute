import { __awaiter } from "tslib";
import { combineLatestWith, filter, map, merge, mergeMap, of, raceWith, switchMap, take, takeUntil } from "rxjs";
import { forActions, inStates, isState } from "@snap/state-management";
import { Injectable } from "../../dependency-injection/Injectable";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { cameraKitSessionFactory } from "../../session/CameraKitSession";
import { getTimeMs } from "../../common/time";
import { operationalMetricReporterFactory } from "../operationalMetricsReporter";
import { configurationToken } from "../../configuration";
import { lensStateFactory } from "../../session/lensState";
import { sessionStateFactory } from "../../session/sessionState";
// We ignore short-duration lens views.
//
// The value is documented here:
// https://docs.google.com/document/d/1-kSzFWCWw9Qo3D08FR1_cqeHTsUtk9p3p3uOptzWDTY/edit#heading=h.q5liip76r9lt
const viewTimeThresholdSec = 0.1;
/**
 * @internal
 */
export const reportLensView = Injectable("reportLensView", [
    cameraKitSessionFactory.token,
    lensStateFactory.token,
    sessionStateFactory.token,
    metricsEventTargetFactory.token,
    operationalMetricReporterFactory.token,
    configurationToken,
], (session, lensState, sessionState, metricsEventTarget, operationalMetricsReporter, configuration) => {
    merge(
    // Begin measuring LensCore apply time once the lens has finished downloading and we actually add the lens
    // to LensCore (LensWait measures the full download + LensCore apply time i.e. perceived UX latency).
    lensState.events.pipe(forActions("downloadComplete"), map(([a]) => a.data)), 
    // If the session is resumed (e.g. user returns to this tab while a lens is on), we count this as a new
    // LensView (and applyDelaySec will be 0).
    lensState.events.pipe(inStates("lensApplied"), switchMap(([, s]) => sessionState.events.pipe(forActions("resume"), takeUntil(lensState.events.pipe(forActions("removeLens"))), map(() => s.data)))))
        .pipe(map((lens) => [getTimeMs(), lens.id]), mergeMap(([applyLensStartTime, lensId]) => {
        const alreadyOn = isState(lensState.getState(), "lensApplied");
        const applyDelay = alreadyOn
            ? of(0)
            : lensState.events.pipe(forActions("resourcesLoaded"), filter(([a]) => a.data.id === lensId), 
            // Applying a new lens may happen before removing the old one, so if we kept taking events
            // we would get the lensResourcesLoaded for the next lens, too.
            take(1), map(() => (getTimeMs() - applyLensStartTime) / 1000));
        const viewMetrics = (alreadyOn
            ? of([getTimeMs(), session.metrics.beginMeasurement()])
            : lensState.events.pipe(forActions("turnedOn"), filter(([a]) => a.data.id === lensId), map(() => [getTimeMs(), session.metrics.beginMeasurement()]))).pipe(take(1), mergeMap(([lensTurnedOnTime, metricsMeasurement]) => lensState.events.pipe(forActions("turnedOff"), 
        // Applying a new lens may happen before removing the old one, so we'll get a
        // lensTurnedOff for the prior lens (if one was applied), which we must filter out.
        filter(([a]) => a.data.id === lensId), 
        // If the session is suspended, we'll count that as the lens turning off.
        raceWith(sessionState.events.pipe(forActions("suspend"))), map(() => {
            metricsMeasurement.end();
            return Object.assign({ viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1000 }, metricsMeasurement.measure());
        }))));
        return applyDelay.pipe(combineLatestWith(viewMetrics), 
        // This lens should always receive the lensTurnedOff action *before* the next lens is turned on.
        // But just in case that assumption is violated, we'll clean up (and not report) if another lens
        // turns on before our lens is turned off.
        takeUntil(lensState.events.pipe(forActions("turnedOn"), filter(([a]) => a.data.id !== lensId))), take(1), map(([applyDelaySec, viewMetrics]) => (Object.assign({ applyDelaySec,
            lensId }, viewMetrics))));
    }))
        .subscribe({
        next: ({ applyDelaySec, lensId, viewTimeSec, avgFps, lensFrameProcessingTimeMsAvg, lensFrameProcessingTimeMsStd, }) => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            if (viewTimeSec < viewTimeThresholdSec)
                return;
            const { cluster: performanceCluster, webglRendererInfo } = (_a = (yield configuration.lensPerformance)) !== null && _a !== void 0 ? _a : {
                cluster: 0,
                webglRendererInfo: "unknown",
            };
            const lensView = {
                name: "lensView",
                applyDelaySec,
                avgFps,
                lensId,
                lensFrameProcessingTimeMsAvg,
                lensFrameProcessingTimeMsStd,
                // We don't support recording video, but applications may do this without our knowledge.
                recordingTimeSec: 0,
                viewTimeSec,
                // TODO: if we want to support these fields, we'll need some persistence to keep track of the
                // date of last application per lens.
                // https://jira.sc-corp.net/browse/CAMKIT-3050
                isLensFirstWithinDay: false,
                isLensFirstWithinMonth: false,
                performanceCluster,
                webglRendererInfo,
            };
            metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensView", lensView));
            // Reporting operational metrics described here:
            // https://docs.google.com/document/d/1g4PncAmKdyrLEFVp8ODp58oer2UJu9PIetRW035nnTo
            //
            // We ignore if applyDelaySec is 0, which will be the case if the session was suspended and then
            // resumed - we only care about this metric when a new lens has been loaded.
            if (applyDelaySec > 0)
                operationalMetricsReporter.timer("lens.core_loading_latency", applyDelaySec * 1000);
            operationalMetricsReporter.timer("lens.processing_time", lensFrameProcessingTimeMsAvg, new Map([["performance_cluster", performanceCluster.toString()]]));
        }),
    });
});
//# sourceMappingURL=reportLensView.js.map